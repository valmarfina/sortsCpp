#include <iostream>
#include <ctime> //для random
#include <algorithm> // для std::swap,в  C++11 <utility>

void random(int array[], const int SIZE)
{
	for (int i = 0; i < SIZE; i++)
	{
		array[i] = rand() % 100 - 50;
	}
}

void outArray(int array[], const int SIZE)
{
	for (int i = 0; i < SIZE; i++)
	{
		std::cout << array[i] << " ";
	}
	std::cout << std::endl;
}

//Сортировка массивa методом выбора
void selection_method(int array[], const int SIZE)//Сортировка массивa методом выбора
{
	/*Сортировка массивa методом выбора
	самая простая для понимания, хотя и одна из самых медленных
	---------------------------------------------------------------------------------------------------------
	1.Начиная с элемента под индексом 0, ищем в массиве наименьшее значение
	2.Найденное значение меняем местами с нулевым элементом
	3.Повторяем шаги №1 и №2 уже для следующего индекса в массиве (отсортированный элемент больше не трогаем)
	*/

	// Перебираем каждый элемент массива(кроме последнего, он уже будет отсортирован, когда мы до него доберемся)
	for (int i = 0; i < SIZE - 1; ++i)
	{
		// В i хранится индекс наименьшего значения, который мы нашли
		// Начинаем с того, что наименьший элемент в этой итерации - это первый элемент (индекс 0)
		int smallestIndex = i;
		// Затем ищем элемент поменьше в остальной части массива
		for (int j = i + 1; j < SIZE; ++j)
		{
			// Если мы нашли элемент, который меньше нашего наименьшего элемента,
			if (array[j] < array[smallestIndex])
			{
				// то запоминаем его
				smallestIndex = j;
			}
		}
		// smallestIndex теперь наименьший элемент. 
		// Меняем местами наше начальное наименьшее число с тем, которое мы обнаружили
		std::swap(array[i], array[smallestIndex]);
	}
}

//сортировка пузырьком
void bubble_Sort(int array[], const int SIZE)
{
	/*
	1.Сравниваются рядом стоящие элементы массива. Если элемент под индексом 0 больше элемента под индексом 1,
	то значения меняются местами.
	2.Затем к следующей паре значений: элемент 1 и элемент 2 и так до тех пор, пока не конец массива.

	*/

	for (int i = 0; i < SIZE - 1; ++i)
	{
		// Перебираем каждый элемент массива до последнего элемента (не включительно).
		// Последний элемент не имеет пары для сравнения
		for (int j = 0; j < SIZE - 1; ++j)
		{
			// Если текущий элемент больше элемента, следующего за ним, то меняем их местами
			if (array[j] > array[j + 1])
				std::swap(array[j], array[j + 1]);
		}
	}
}

//улучшенная сортировка пузырьком (Сортировка расчёской/Comb sort)
void improved_bubbleSort(int array[], const int SIZE)
{
	for (int i = 0; i < SIZE - 1; ++i)
	{
		// Последний элемент будет отсортирован и в каждой последующей итерации цикла
		// поэтому сортировка «заканчивается» на один элемент раньше
		int endOfArrayI(SIZE - i);

		bool swapped(false); // отслеживаем, были ли выполнены замены в этой итерации

		// Перебираем каждый элемент массива до последнего (не включительно).
		// Последний элемент не имеет пары для сравнения
		for (int j = 0; j < endOfArrayI - 1; ++j)
		{
			// Если текущий элемент больше элемента, следующего за ним,
			if (array[j] > array[j + 1])
			{
				// то выполняем замену
				std::swap(array[j], array[j + 1]);
				swapped = true;
			}
		}
		// Если в этой итерации не выполнилось ни одной замены, то цикл можно завершать
		if (!swapped)
		{
			// Выполнение начинается с 0-й итерации, поэтому для подсчета количества итераций добавляем 1
			i += 1;
			break;
		}
	}
}

//Сортировка вставками
void insertion_sort(int array[], const int SIZE)
{
	/*
	Сортировка вставками наиболее эффективна когда массив уже частично отсортирован и когда элементов массива не много. 
	Если же элементов меньше 10 то данный алгоритм является лучшим. 

	На каждом шаге сортировки сравнивается текущий элемент со всеми элементами в отсортированной части.
	*/

	int temp, // временная переменная для хранения значения элемента сортируемого массива
		item; // индекс предыдущего элемента

	for (int i = 1; i < SIZE; i++)
	{
		temp = array[i]; // инициализируем временную переменную текущим значением элемента массива
		item = i - 1; // запоминаем индекс предыдущего элемента массива
		while (item >= 0 && array[item] > temp) // пока индекс не равен 0 и предыдущий элемент массива больше текущего, изменив знак на >, массив будет сортироваться по убыванию.
		{
			array[item + 1] = array[item]; // перестановка элементов массива
			array[item] = temp;
			item--;
		}
	}
}

//сортировка Шелла(улучшенная cортировка вставками)
void shell_sort(int array[], const int SIZE)
{
	/*
	1.Сначала отдельно группируются и сортируются элементы, 
	отстоящие друг от друга на 4 позиции. Такой процесс называется четвертной сортировкой.

	2.После первого прохода элементы перегруппировываются — теперь каждый элемент группы 
	отстоит от другого на 2 позиции — и вновь сортируются (двойная сортировка).

	3.На третьем проходе идет обычная сортировка.

	*/

	int increment = 3;    // начальное приращение сортировки
	while (increment > 0)  // пока существует приращение
	{
		for (int i = 0; i < SIZE; i++)  // для всех элементов массива
		{
			int j = i;          // сохраняем индекс и элемент
			int temp = array[i];
			// просматриваем остальные элементы массива, отстоящие от j-ого
			// на величину приращения
			while ((j >= increment) && (array[j - increment] > temp))
			{  // пока отстоящий элемент больше текущего
				array[j] = array[j - increment]; // перемещаем его на текущую позицию
				j = j - increment;       // переходим к следующему отстоящему элементу
			}
			array[j] = temp; // на выявленное место помещаем сохранённый элемент
		}
		if (increment > 1)      // делим приращение на 2
			increment = increment / 2;
		else if (increment == 1)   // последний проход завершён,
			break;  // выходим из цикла
	}
}


int main()
{
	setlocale(LC_ALL, "Russian");

	//установка генератора случайных чисел; функция time(0) объявлена в <ctime>
	srand(time(0));

	const int SIZE = 30;
	int array[SIZE];

	random(array, SIZE);

	//=========================================
	std::cout << "Вывод массива до сортировки: " << std::endl;
	outArray(array, SIZE);
	selection_method(array, SIZE);
	std::cout << "Вывод массива после сортировки выбором: " << std::endl;
	outArray(array, SIZE);

	//=========================================
	random(array, SIZE);
	std::cout << "Вывод массива до сортировки: " << std::endl;
	outArray(array, SIZE);
	bubble_Sort(array, SIZE);
	std::cout << "Вывод массива после сортировки пузырьком: " << std::endl;
	outArray(array, SIZE);
	//=========================================
	random(array, SIZE);
	std::cout << "Вывод массива до сортировки: " << std::endl;
	outArray(array, SIZE);
	improved_bubbleSort(array, SIZE);
	std::cout << "Вывод массива после улучшенной сортировки пузырьком: " << std::endl;
	outArray(array, SIZE);
	//=========================================
	random(array, SIZE);
	std::cout << "Вывод массива до сортировки: " << std::endl;
	outArray(array, SIZE);
	insertion_sort(array, SIZE);
	std::cout << "Вывод массива после сортировки вставками: " << std::endl;
	outArray(array, SIZE);
	//=========================================
	random(array, SIZE);
	std::cout << "Вывод массива до сортировки: " << std::endl;
	outArray(array, SIZE);
	shell_sort(array, SIZE);
	std::cout << "Вывод массива после сортировки Шелла: " << std::endl;
	outArray(array, SIZE);

	return 0;
}